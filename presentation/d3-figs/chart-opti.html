<!DOCTYPE html>
<meta charset="utf-8">
<script src="../js/mathjax_macros.js"></script>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            macros: texMacros,
        },
        svg: {
            fontCache: 'global'
        }
    };
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script src="../js/d3.v7.min.js"></script>

<body>
    <script>
        function linspace(start, end, steps) {
            const stepSize = (end - start) / (steps - 1);
            const result = [];

            for (let i = 0; i < steps; i++) {
                result.push(start + i * stepSize);
            }

            return result;
        }

        function convertLaTeXToSVG(latexExpression) {
            // Create a temporary div to render the LaTeX
            const div = document.createElement("div");
            div.style.visibility = "hidden";
            div.innerHTML = `$${latexExpression}$`;

            // Append the div to the document
            document.body.appendChild(div);
            // call the typeset
            MathJax.typeset();


            // Retrieve the SVG element generated by MathJax
            const svgElement = div.querySelector("svg");

            // Remove the temporary div
            document.body.removeChild(div);

            //console.log(svgElement);
            return svgElement;
        }

        const xes = linspace(0, 1, 100);

        function compressive_strength(x) {
            let steepness = 7;
            let offset = 5.
            let x_trans = steepness * (x - 0.5);
            return 24. * (1 - sigmoid(x_trans - 0.4)) + offset;
        }

        function slump(x) {
            let steepness = 7;
            let offset = 10.
            let x_trans = steepness * (x - 0.5);
            return 24. * sigmoid(x_trans - 0.4) + offset;
        }

        function generateData(fun) {
            return xes.map((x) => ({
                x: x,
                y: fun(x)
            }));
        }

        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        function generateXData(value, ymin, ymax) {
            return [{x: value, y: ymin}, {x: value, y: ymax}];
        }

        function normalize(v) {
            let sm = d3.sum(v);
            return v.map((x) => x / sm);
        }

        function zeros(len) {
            let data = [];
            for (let i = 0; i < len; i++) {
                data.push(0);
            }
            return data;
        }


        function removeElement(id) {
            let element = d3.select(`#${id}`);
            console.log(element);
            if (element !== null) {
                element
                    .transition()
                    .duration(500)
                    .style("opacity", 0)
                    .on("end", () => (element.remove()))
                //element.exit().remove();
            } else {
                console.warn(`Could not find element with id ${id}`)
            }
        }

        function drawLine(line_id) {
            let line = d3.select(`#${line_id}`);
            if (line !== null) {
                drawLineAux(line);
            };
        }

        function drawLineAux(line) {
            let length = line.node().getTotalLength();

            line.attr("stroke-dasharray", length + " " + length)
                .attr("stroke-dashoffset", function () {return this.getTotalLength();})
                .transition()
                .duration(500)
                .attr("stroke-dashoffset", 0);
        }

        function annotate({label, xpos, ypos, color = "white", id = "label", transform = "", parent = svg}) {
            const latexSVG = convertLaTeXToSVG(label);

            let width_obj = latexSVG.width.baseVal;
            const width = width_obj.valueAsString;// valueAsString;
            const height = latexSVG.height.baseVal.valueAsString;
            let label_svg = parent.append("foreignObject")
                .attr("x", xpos) //width / 2) // Adjust the position as needed
                .attr("y", ypos)// height + 20)     // Adjust the position as needed
                .attr("transform", transform)
                .attr("width", width)
                .attr("height", "25px")
                .attr("color", color)
                .attr("opacity", 0)
                .attr("id", id)
                .html(new XMLSerializer().serializeToString(latexSVG));

            label_svg.transition()
                .duration(500)
                .attr("opacity", 1);

            return label_svg;
        }

        // Set the dimensions of the plot

        const margin = {top: 10, right: 50, bottom: 60, left: 55};
        const width = 450 - margin.left - margin.right;
        const height = 300 - margin.top - margin.bottom;

        const svg = d3.select('body')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);

        // Create a scale for the x-axis
        const xScale = d3.scaleLinear()
            .domain([0, 1]) // x-axis range from 0 to 10
            .range([0, width]);

        // Create a scale for the y-axis
        const yScale = d3.scaleLinear()
            .domain([0, 50]) // Adjust the domain as needed
            .range([height, 0]);

        const yScale_slump = d3.scaleLinear()
            .domain([0, 20]) // Adjust the domain as needed
            .range([height, 0]);

        // Create a line generator
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));

        // Create the x-axis
        const xAxis = d3.axisBottom(xScale);

        // Create the y-axis
        const yAxis = d3.axisLeft(yScale);
        const yAxis2 = d3.axisRight(yScale_slump);

        const addLine = (data, color, width, id) => {
            let g = svg.append("g").
                attr("id", `${id}_group`)
            g.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", color)
                .attr("stroke-width", width)
                .attr("id", id)
                .attr("d", line)
                .attr("stroke-dashoffset", function () {return this.getTotalLength();})
            return g
        };

        let data = generateData(compressive_strength);

        let str_line_g = addLine(data, "lightgray", 2, "strength_id");
        drawLine("strength_id");
        annotate({
            label: "f(x)",
            xpos: 2 * width / 3,
            ypos: (50 - compressive_strength(2. / 3.)) / 50 * height - 25,
            color: "lightgray",
            parent: str_line_g,
        });

        // Append the x-axis to the SVG
        svg.append("g")
            .attr("class", "x-axis")
            .attr("color", "white")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        // Append the y-axis to the SVG
        let y_axis = svg.append("g")
            .attr("color", "white")
            .attr("class", "y-axis")
            .call(yAxis);

        annotate({
            label:
                "\\text{Compressive strength [MPa]}",
            xpos: -width / 1.8,
            ypos: -40,
            transform: "rotate(-90)",
            parent: y_axis
        });

        annotate({
            label: "\\text{Water to cement ratio } x",
            xpos: 0.6 * width / 2,
            ypos: height + 20
        });

        // Draw the constraint boundary
        let bdData = generateXData(0.7, 0, 50);

        let slump_line_id = "slump_line_id";
        let slump_ax_id = "slump_id";
        let slump_constr_id = "slump_constr_id";

        let slump_data = generateData(slump);


        function render(what) {
            switch (what) {
                case "slump-on":
                    let y_axis_slump = svg.append("g")
                        .attr("color", "green")
                        .attr("class", "y-axis")
                        .attr("transform", `translate(${width}, 0)`)
                        .attr("id", slump_ax_id)
                        .call(yAxis2) // Extend ticks and add padding
                    let slump_line = addLine(slump_data, "green", 2, slump_line_id);
                    drawLine(slump_line_id)
                    annotate({
                        label: "g(x)",
                        xpos: 2 * width / 3,
                        ypos: (50 - slump(2. / 3.)) / 50 * height - 35,
                        color: "green",
                        parent: slump_line
                    });
                    annotate({
                        label: "\\text{Slump [mm]}",
                        xpos: -2 * height / 3.,
                        ypos: 25,
                        color: "green",
                        transform: "rotate(-90)",
                        parent: y_axis_slump
                    });
                    break;
                case "slump-off":
                    removeElement(slump_ax_id);
                    removeElement(slump_line_id + "_group");
                    break;

                case "constr-on":
                    addLine(bdData, "green", 1., slump_constr_id);
                    break;
                case "constr-off":
                    removeElement(slump_constr_id);
                    break;

                default:
                    break;
            }
        }

        render();

        var _transitions = [
            {
                transitionForward: () => render("slump-on"),
                transitionBackward: () => render("slump-off"),
                index: 0
            },
            {
                transitionForward: () => render("constr-on"),
                transitionBackward: () => render("constr-off"),
                index: 1
            },
            {
                transitionForward: () => render("default-on"),
                transitionBackward: () => render("default-off"),
                index: "onSlideChange"
            },
        ]
    </script>
</body>
