<!DOCTYPE html>
<meta charset="utf-8">
<script src="../js/mathjax_macros.js"></script>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            macros: texMacros,
        },
        svg: {
            fontCache: 'global'
        }
    };
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script src="../js/d3.v7.min.js"></script>

<body>
    <script>
        function linspace(start, end, steps) {
            const stepSize = (end - start) / (steps - 1);
            const result = [];

            for (let i = 0; i < steps; i++) {
                result.push(start + i * stepSize);
            }

            return result;
        }

        function convertLaTeXToSVG(latexExpression) {
            // Create a temporary div to render the LaTeX
            const div = document.createElement("div");
            div.style.visibility = "hidden";
            div.innerHTML = `$${latexExpression}$`;

            // Append the div to the document
            document.body.appendChild(div);
            // call the typeset
            MathJax.typeset();


            // Retrieve the SVG element generated by MathJax
            const svgElement = div.querySelector("svg");

            // Remove the temporary div
            document.body.removeChild(div);

            //console.log(svgElement);
            return svgElement;
        }


        function seededRandom(seed) {
            let state = seed % 2147483647;
            if (state <= 0) state += 2147483646; // Ensure the seed is a positive integer

            return () => {
                state = (state * 16807) % 2147483647;
                return (state - 1) / 2147483646;
            };
        }

        const xes = linspace(0, 10, 100);

        function f(x, ran) {
            return 0.18 * Math.pow(x - 5, 2) + 2 * Math.pow(ran, 0.5) + 2 * ran * Math.sin(ran * 0.4 * x)
        }

        function generateData(ran) {
            return xes.map((x) => ({
                x: x,
                y: f(x, ran)
            }));
        }

        function generateMaxData(rans) {
            return xes.map((x) => ({
                x: x,
                y: Math.max(...rans.map((ran) => f(x, ran)))
            }));
        }

        function normalize(v) {
            let sm = d3.sum(v);
            return v.map((x) => x / sm);
        }

        function zeros(len) {
            let data = [];
            for (let i = 0; i < len; i++) {
                data.push(0);
            }
            return data;
        }

        function removeElement(id) {
            let element = d3.select(`#${id}`);
            console.log(element);
            if (element !== null) {
                element
                    .transition()
                    .duration(500)
                    .style("opacity", 0)
                    .on("end", () => (element.remove()))
                //element.exit().remove();
            } else {
                console.warn(`Could not find element with id ${id}`)
            }
        }

        function drawLine(line_id) {
            let line = d3.select(`#${line_id}`);
            if (line !== null) {
                drawLineAux(line);
            };
        }


        function drawLineAux(line) {
            let length = line.node().getTotalLength();

            line.attr("stroke-dasharray", length + " " + length)
                .attr("stroke-dashoffset", function () {return this.getTotalLength();})
                .transition()
                .duration(500)
                .attr("stroke-dashoffset", 0);
        }

        function annotate(label, xpos, ypos, color = "white", id = "label") {
            const latexSVG = convertLaTeXToSVG(label);

            const width = latexSVG.width.baseVal.valueAsString;
            const height = latexSVG.height.baseVal.valueAsString;
            let label_svg = svg.append("foreignObject")
                .attr("x", xpos) //width / 2) // Adjust the position as needed
                .attr("y", ypos)// height + 20)     // Adjust the position as needed
                .attr("width", width)
                .attr("height", "20px")
                .attr("color", color)
                .attr("opacity", 0)
                .attr("id", id)
                .html(new XMLSerializer().serializeToString(latexSVG));

            label_svg.transition()
                .duration(500)
                .attr("opacity", 1);

            return label_svg;
        }

        // Set the dimensions of the plot

        const margin = {top: 10, right: 10, bottom: 60, left: 50};
        const width = 450 - margin.left - margin.right;
        const height = 300 - margin.top - margin.bottom;

        const svg = d3.select('body')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);

        // Create a scale for the x-axis
        const xScale = d3.scaleLinear()
            .domain([0, 1]) // x-axis range from 0 to 10
            .range([0, width]);

        // Create a scale for the y-axis
        const yScale = d3.scaleLinear()
            .domain([0, 10]) // Adjust the domain as needed
            .range([height, 0]);

        // Create a line generator
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));

        // Create the x-axis
        const xAxis = d3.axisBottom(xScale);

        // Create the y-axis
        const yAxis = d3.axisLeft(yScale);

        let data = []

        const addLine = (data, color, width, id) => {
            return svg.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", color)
                .attr("stroke-width", width)
                .attr("id", id)
                .attr("d", line)
                .attr("stroke-dashoffset", function () {return this.getTotalLength();})
        };

        const random_range = linspace(0.4, 1.7, 20);

        var curr_line;
        for (randomness of random_range) {
            data = generateData(randomness);
            curr_line = addLine(data, "lightgray", 1);
            drawLineAux(curr_line);
        }
        annotate("\\ell(x, \\xi)", 2 * width / 3, height / 2, "lightgray");

        //const meandata = generateMeanData(random_range);
        const maxdata = generateMaxData(random_range);
        //const empmeandata = generateEmpmeanData(random_range);
        //const drodata = generateDroData(random_range);

        // Append the x-axis to the SVG
        svg.append("g")
            .attr("class", "x-axis")
            .attr("color", "white")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        // Append the y-axis to the SVG
        svg.append("g")
            .attr("color", "white")
            .attr("class", "y-axis")
            .call(yAxis);

        annotate("x", width / 2, height + 20);


        var robust_line = "robust_line";
        var mean_line = "mean_line";
        var empmean_line = "empmean_line";
        var dro_line = "dro_line";
        var robust_label = "robust_label";
        var mean_label = "mean_label";
        var empmean_label = "empmean_label";
        var dro_label = "dro_label";

        //        var robust_line = null;
        //        var mean_line = null;
        //        var empmean_line = null;
        //        var dro_line = null;
        //
        //        var robust_label = null;
        //        var mean_label = null;
        //        var empmean_label = null;
        //        var dro_label = null;

        function render(type) {

            switch (type) {
                case "robust-on":
                    // code block
                    addLine(maxdata, "steelblue", 2, robust_line);
                    drawLine(robust_line)
                    annotate("\\max_{\\xi \\in \\Xi} \\ell(x, \\xi)", 0.2 * width, 0.15 * height, "steelblue", robust_label);
                    break;
                case "robust-off":
                    // code block
                    removeElement(robust_line);
                    removeElement(robust_label);
                    break;
                case "mean-on":
                    // code block
                    //addLine(meandata, "black", 2, mean_line);
                    drawLine(mean_line);
                    annotate("\\E_{\\xi \\sim \\prob^{\\star}}[\\ell(x, \\xi)]", 0.2 * width, 0.7 * height, "black", mean_label);
                    break;
                case "mean-off":
                    removeElement(mean_line);
                    removeElement(mean_label);
                    break;
                case "empmean-on":
                    // code block
                    addLine(empmeandata, "red", 2, empmean_line);
                    drawLine(empmean_line);
                    annotate("\\frac{1}{n} \\sum_{k=1}^{n}[\\ell(x, \\xi_k)]", 0.3 * width, 0.8 * height, "red", empmean_label);
                    break;
                case "empmean-off":
                    removeElement(empmean_line);
                    removeElement(empmean_label);
                    break;
                case "dro-on":
                    // code block
                    addLine(drodata, "green", 2, dro_line);
                    drawLine(dro_line);
                    annotate("\\rho[\\ell(x, \\xi)]", 0.6 * width, 0.7 * height, "green", dro_label);
                    break;
                case "dro-off":
                    removeElement(dro_line);
                    removeElement(dro_label);
                    break;
                default:
                    break;
            }
        }

        render();

        var _transitions = [
            {
                transitionForward: () => render("mean-on"),
                transitionBackward: () => render("mean-off"),
                index: 0
            },
            {
                transitionForward: () => render("empmean-on"),
                transitionBackward: () => render("empmean-off"),
                index: 2
            },
            {
                transitionForward: () => render("robust-on"),
                transitionBackward: () => render("robust-off"),
                index: 3
            },
            {
                transitionForward: () => render("dro-on"),
                transitionBackward: () => render("dro-off"),
                index: 4
            },
            {
                transitionForward: () => render("default-on"),
                transitionBackward: () => render("default-off"),
                index: "onSlideChange"
            },
        ]

    </script>
</body>
